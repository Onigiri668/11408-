# 第一章计算机系统概述

## 1.1 计算机发展历程

### 1.1.1 计算机硬件的发展

* **计算机系统 = 硬件 + 软件**
* **计算机硬件的发展：**
  * 第一代计算机：使用电子管
  * 第二代计算机：使用晶体管
  * 第三代计算机：使用较小规模的集成电路
  * 第四代计算机：使用较大规模的集成电路

**发展趋势：更微型，多用途；更巨型，超高速。**

> 晶体管之父：肖克利（1956年诺贝尔物理学奖得主）
>
> ​	1957年：“八叛徒“创立了仙童半导体
>
> ​	1959年：仙童半导体发明了”集成电路“
>
> ​	1968年：摩尔离开仙童，创立Intel
>
> ​	1969年：仙童销售部负责人桑德斯离开仙童，创立AMD

摩尔定律：集成电路上的晶体管数量每18个月就会翻一倍，所以每18个月计算机的处理效率就会提高一倍。

### 1.1.2 计算机软件的发展

计算机软件技术的发展，促进计算机系统的发展。

计算机语言的发展经历了面向机器的机器语言和汇编语言，面向问题的高级语言，其中高级语言的发展真正促进了软件的发展，它经历了从科学计算的**FORTRAN结构化程序设计的PASCAL**到**面向对象的C++和适应网络环境的JAVA**。

同时，直接影响计算机系统性能的提升的各种系统软件也有了长久的发展，特别是操作系统，如Windows ，UNIX，Linux等。

### 1.1.3 计算机的分类与发展方向

可以分为：

​	电子模拟计算机和电子数字计算机。

数字计算机又可以按照用途分为：

* 专用计算机和通用计算机
* 通用计算机又分为：巨型机，大型机，中型机，小型机，微型机和单片机

按照指令和数据流可以分为：

* 单指令流和单数据流系统（SISD），即传统给的冯·诺依曼体系结构。
* 单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。
* 多指令流和单数据流系统（MISD），这种计算机**实际上不存在**。
* 多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。

## 1.2 计算机系统结构

### 1.2.1 计算机系统的组成

计算机系统是由**硬件系统**和**软件系统**共同构建起来的。

### 1.2.2 计算机硬件的基本组成

1. 早期的冯·诺依曼机
   美籍匈牙利科学家冯·诺依曼最先提出”程序存储“的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为”现代计算机之父“。

> 什么是存储程序原理？按此原理，计算机应具有哪几大功能？
>
> **”程序存储“**：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的是地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即**按地址访问并顺序执行指令**。计算机按照此原理应具有5大功能：
>
> 数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能。



> 冯·诺依曼体系结构特点：
>
> * 计算机硬件系统由五大部件组成：存储器，运算器，控制器，输出设备，输入设备
> * 指令和数据以**同等地位**存于存储器，可按地址寻访
> * 指令和数据用二进制表示
> * 指令由操作码和地址码组成
> * 存储程序
> * 以**运算器**为中心
>
> 早起的冯·诺依曼机以运算器为中心，且是单处理机，**最根本的特征是采用”存储程序“原理**，基本工作方式是**控制流驱动方式**

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221522747.png)

2. 现代计算机的组织结构

![现代计算机的组织结构](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221523732.png)

3. 计算机的功能部件

主机：主存，运算器，控制器

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221523545.png)

五大部分：

1. 输入设备是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等
2. 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。
3. 存储器，存储器分为**主存储器**(内存储器，**CPU能直接访问**)和**辅助存储器**(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。
   **主存储器**的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(**相联存储器**既可以既可以按照**地址寻址**，又可以按照**内容寻址**，为了与传统存储器区别，又称为**内容寻址的存储器**！
   主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221526852.png)
4. 运算器，是计算机的运算单元，用于算术运算和逻辑运算。运算器的核心单元是算术逻辑单元(ALU)
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221526892.png)
5. 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221527012.png)

一般将**运算器和控制器**集成到同一个芯片上，称为**中央处理器(CPU)**。**CPU和主存储器**共同构成**主机**，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。

CPU和主存之间通过**一组总线**相连，总线中有**地址、控制和数据3组信号线**。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存还是从主存读出到CPU,根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

### 1.2.3 计算机软件的分类

1. 系统软件和应用软件

计算机软件：一般分为系统软件和应用软件

* 系统软件包括操作系统，数据库管理系统，数据处理系统（比如编译器），分布式软件系统，网络软件系统，标准库系统，服务型系统（比如连接程序）。
* 应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。

> 注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是有数据库，数据库管理系统，数据库管理员和应用程序构成。所以只能说它里面有系统软件，但并不能说它为系统软件。

2. 三个级别的语言
   1. 机器语言：又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。**机器语言是计算机唯一可以直接识别和执行的语言。**
   2. 汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个成为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。
   3. 高级语言：高级语言（如C，C++，Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

> 由高级语言转换到汇编语言的过程叫做**编译**，由汇编语言转换到机器语言的过程叫**汇编**，边翻译边执行叫做**解析**。

### 1.2.4 计算机的工作过程

**IR**存放当下欲执行的指令；**PC**存放下一条指令的地址；**MAR**存放欲访问的存储单元地址；**MDR**存放从存储单元取来的数据；**地址译码器**是主存的构成部分，不属于CPU；**地址寄存器**虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器。

关于CPU存取速度的比较：寄存器（CPU内部）> Cache（高速的SRAM）> 内存（RAM）

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221539734.png)

## 1.3 计算机性能指标

1. 机器字长

**计算机的位数**（机器字长），表示计算机进行一次整数运算即（定点整数运算）所能处理的二进制数据的位数。计算机字长通常选定为字节（8位）的整数倍，通常是2,4,8倍。不同的计算机字节可能不同。

> **机器字长，指令字长，存储字长的区别和联系是什么？**
>
> * 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
> * 指令字长：一个指令字中包含的二进制代码的位数。
> * **存储字长**：一个存储单元存储的二进制代码的长度。**等于MDR的位数**，他们都必须是字节的整数倍。
> * 数据字长：**数据总线一次能传送信息的位数**，它可以不等于MDR的位数。
>
> 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍。若指令字长等于存储字长，则取指周期等于机器周期。

2. 数据通路带宽

数据总线一次能传送信息的位数。

3. 主存容量

MAR的位数反应存储单元的个数，如MAR为16位，表示存储单元为2^16^=64K；若MDR为32位，则存储容量为2^16^x32。

> **2^10^ : K		2^20^ : M		2^30^ : G		2^40^ : T**

4. 运算速度

**吞吐量**：指系统在单位时间内处理请求的数据的数量；从用户观点看，它是**评价计算机系统性能的综合参数**。

相应时间：指从用户向计算机发送一个请求，到系统作出相应并获得所需结构的等待时间。

**CPU时钟周期**：通常为节拍脉冲或T周期，即主频的倒数，**它是CPU中最小的时间单位**，每一个动作至少需要1个时钟周期。

主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。

* CPU周期又称为机器周期，由多个时钟周期组成
* 指令周期 > CPU周期 > 时钟周期

**CPI（Clock cycle Per Instruction）：即执行一条指令所需的时钟周期数。**

CPU执行时间：指裕兴一个程序所花费的时间。

CPU执行时间 = CPU时钟周期数/主频 = （指令条数 x CPI）/ 主频

CPU的性能取决于三个要素：主频、CPI、指令条数

> IPS = 主频 / 平均CPI  ——每秒执行多少指令
>
> MIPS ——即每秒执行多少百万条指令
>
> MFLOPS = 浮点操作次数 / 执行时间 x 10^6^ ——即每秒执行多少百万次浮点运算
>
> GFLOPS = 浮点操作次数 / 执行时间 x 10^9^ ——即每秒执行多少十亿次浮点运算
>
> TFLOPS = 浮点操作次数 / 执行时间 x 10^12^ ——即每秒执行多少万亿次浮点运算

# 第二章 数据的表示与运算

## 2.1 数制与编码

### 2.1.1 进位计数指及其相互转化

进位计数值：

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221657969.png)

### 2.1.2 BCD码（Binary-code Decimal码）

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221658766.png)

> 8421码注：
>
> 1. 每4个二进制位对应一个十进制位（由6个冗余状态）
> 2. 8,4,2,1分别对应每一位的权值
> 3. 0000~1001分别对应0-9，进行加法后若超出该范围则需+0110进行修正（强制向高位进1），若相加结果在合法范围内，无需修正
> 4. 8421码中1010~1111没有定义
>
> 2421码注：
>
> 2,4,2,1分别对应每一位的权值，表示0-4时最高位为0，表示5-9时最高位为1

### 2.1.3 无符号整数的表示和运算

1. 无符号整数的表示

各个数值位的”位权“ ：|2^7^|2^6^|2^5^|2^4^|2^3^|2^2^|2^1^|2^0^| 8bit寄存器

**无符号整数**：

* 全部二进制位都是数值位，没有符号位，第$i$位的位权是2^i-1^
* nbit无符号整数**表示范围为（0~2^n^-1）**，超出则**溢出**，意味着该计算机无法一次处理这么多
* 可以表示的**最小数：全0**，可以表示的**最大数：全1**

2. 无符号整数的加法运算

计算机硬件如何做无符号整数的**加法**：从最低位开始，**按位相加**，并往更高位**进位**。

3. 无符号整数的减法运算

计算机硬件如何做无符号整数的减法：

​	① “被减数”不变，**“减数”**==全部位==**按位取反，末位+1，减法变加法**

​	② 从最低位开始，**按位相加**，并往更高位**进位**

### 2.1.4 带符号整数的表示和运算

1. 带符号整数的表示

   1. 原码表示

   **原码**： ①  符号位“0/1”对应"正/负"，剩余的数值位表示真值和绝对值

   ​            ② 若机器字长n+1位，带符号整数的原码表示范围：**-(2^n^-1) ≤ x ≤ 2^n^-1**

   ​	    ③ 真值0有两种形式：**+0**和**-0** ， [+0]~原~ = 0.0000000 ； [-0] = 1.0000000；

   ​		常见的书面写法：x = -19        [x]~原~ = 1.0010011

   ​		若未指明机器字长，也可写为：[x]~原~ = 1.10011

   ​		**原码**的缺点：**符号位不能参与运算**，需要设计复杂的硬件电路才能处理

   ​		用补码表示真值——符号位可参与运算

   2. 原码 → 反码 → 补码的转换（机算）

   **正数**：   |原码| ←----------------不变----------------→ |反码|  ←----------------不变----------------→ |补码|

   **负数**：   |原码| ←---**符号位不变数值位取反**----→ |反码|  ------------------**末位+1**--------------→ |补码|

   3. 原码、补码快速转换技巧（手算）

   **正数**：   |原码| ←------------------------------------------不变------------------------------------------→|补码|

   **负数**：   |原码| ←-----**从右往左找到第一个1，这个1左边的所有“数值位”按位取反**-----→|补码|

   4. 补码的加法运算

   **符号位0正1负**      |符|~~2^6^~~|~~2^5^~~|~~2^4^~~|~~2^3^~~|~~2^2^~~|~~2^1^~~|~~2^0^~~|      **补码数值位不能解读为“位权”**

   计算机硬件如何做补码的加法：从最低位开始，**按位相加（符号位参与运算）**，并往更高位**进位**。

   5. 补码的减法运算

   [A]~补~ - [B]~补~ = [A]~补~ + [-B]~补~

   ​		|[B]~补~| ←------**全部位按位取反，末位+1**------→ |[-B]~补~|

   计算机硬件如何做带符号数补码的减法：

   ① “被减数”不变，**“减数”全部位按位取反，末位+1**，减法变加法

   ② 从最低位开始，**按位相加**，并往更高位**进位**

   |       n+1 bit        |        合法表示范围        |  最大的数  |  最小的数   |                   真值0的表示                   |
   | :------------------: | :------------------------: | :--------: | :---------: | :---------------------------------------------: |
   |   带符号整数：原码   | -(2^n^ - 1) ≤ x ≤ 2^n^ - 1 |  2^n^ - 1  | -(2^n^ - 1) | [+0]~原~ = 0.000...00<br />[-0]~原~ = 1.000..00 |
   |   带符号整数：反码   | -(2^n^ - 1) ≤ x ≤ 2^n^ - 1 |  2^n^ - 1  | -(2^n^ - 1) | [+0]~反~ = 0.000...00<br />[-0]~反~ = 1.000..00 |
   | 带符号整数：**补码** |  **-2^n^** ≤ x ≤ 2^n^ - 1  |  2^n^ - 1  |    -2^n^    | [0]~补~ = 0.000...00<br />**真值0只有一种补码** |
   |      无符号整数      |     0 ≤ x ≤ 2^n+1^ - 1     | 2^n+1^ - 1 |      0      |                   0.000...000                   |

   原码和反码的合法表示范围完全相同，都有两种方法表示真值0

   **补码**的合法表示范围比原码**多一个负数**，只有一种方法表示真值0

   6. 移码

   **移码**：补码的基础上将**符号位取反**。**注意：移码只能用于表示整数**

### 2.1.7 定点小数

1. 原码

定点小数

​	|X~0~|     |X~1~|X~2~|...|X~n~|			|符|2^-1^|2^-2^|2^-3^|2^-4^|2^-5^|2^-6^|2^-7^|

​    符号位  ↑       数值部分

​	小数点位置（隐含）

**原码**：符号位“0 / 1" 对应”正 / 负“

![image-20231122190224157](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221902376.png)

2. 定点小数的加/减法运算

对两个顶点小数A，B进行加法/减法时，需要先转换为补码

计算机硬件如何做**定点小数补码**的加法：从最低位开始，**按位相加（符号位参与运算）**，并往更高位**进位**

计算机硬件如何做**定点小数补码**的减法：

​	① ”被减数“不变，”减数”全部位按位取反，末位+1，减法变加法

​	② 从最低位开始，**按位相加**，并往更高位**进位**

| n+1 bit            | 合法表示范围                 | 最大的数  | 最小的数     | 真值0的表示                                     |
| ------------------ | ---------------------------- | --------- | ------------ | ----------------------------------------------- |
| 定点小数：原码     | -(1 - 2^-n^) ≤ x ≤ 1 - 2^-n^ | 1 - 2^-n^ | -(1 - 2^-n^) |                                                 |
| 定点小数：反码     | -(1 - 2^-n^) ≤ x ≤ 1 - 2^-n^ | 1 - 2^-n^ | -(1 - 2^-n^) |                                                 |
| 定点小数：**补码** | **-1** ≤ x ≤ 1 - 2^-n^       | 1 - 2^-n^ | -1           | **[0]~补~ = 0.000...00<br />真值0只有一种补码** |

### 2.2.0 奇偶校验码

校验码：任意两个码字之间最少变化的二进制位数称为码距，码距大于等于2的数据校验码开始具有检错的能力。**码距越大，检错，纠错能力越强**。就校验码的码距等于2，可以检测出以为错误（或技术位错误），但不能确定出错的位置，也不能检测出偶数位错误，**仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距。**

具有检，纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。

奇偶校验码：

* 奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数
* 偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数

> 奇偶校验码的码距d = 2 ， 仅能检测出奇数位错误，无纠错能力。
>
> 偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验位。

### 2.2.1 电路的基本原理，加法器设计

1. 算数逻辑单元（ALU）

![image-20231122191739225](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221917416.png)

2. 电路基础知识

​	① 逻辑运算

![image-20231122191949674](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221919803.png)

![image-20231122192247114](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221922264.png)

3. 加法器的实现

​	① 一位全加器的设计

![image-20231122192656558](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221926734.png)

​	② 串行加法器

![image-20231122193031333](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221930480.png)

​	③ 并行加法器

![image-20231122193507574](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221935724.png)

### 2.2.2 并行进位加法器

![image-20231122193654716](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221936849.png)

### 2.2.3 补码加减运算器

![image-20231122193955080](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221939223.png)

### 2.2.4 加减运算和溢出判断

1. 原码

   1. 加法

   同号相加：数值部分 = 被加数，加数的绝对值进行相加，符号位不变。

   异号相加：数值部分 = 被加数，加数中绝对值更大的减绝对值更小的。符号位于绝对值更大的数相同。

   2. 减法

   将减数取负，转变为加法。

2. 补码

对于补码来说，无论加法还是减法，**最后都会转变成加法**，由加法器实现运算，符号位也参与运算。

3. 溢出判断

![image-20231122194409944](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221944123.png)

* 只有“正数+正数”才会**上溢**——正+正=负
* 只有“负数+负数”才会下溢——负+负=正

方法一：采用一位符号位

设A的符号位为A~S~，B的符号位为B~S~，运算结果的符号为S~S~，则溢出逻辑表达式为：
$$
V = A_SB_S\overline{ S_S} + \overline{A_SB_S}S_S
$$
若V = 0，表示无溢出；若V = 1，表示有溢出

方法二：**采用一位符号位，根据数据位进位情况判断溢出**

|      | 符号位的进位C~S~ | 最高数值位的进位C~1~ |
| ---- | ---------------- | -------------------- |
| 上溢 | 0                | 1                    |
| 下溢 | 1                | 0                    |

即：C~S~与C~1~不相同时有溢出

方法三：**采用双符号位**

正数符号为00，负数符号为11

记两个符号位为S~S1~，S~S2~，则V = S~S1~ ⊕ S~S2~

若V = 0 表示无溢出；若V = 1，表示有溢出

双符号位补码又称：模4补码；单符号位补码又称：模2补码

> 实际存储时值存储1个符号位，运算时会复制一个符号位

4. 符号扩展

① 定点整数的符号扩展：在原符号位和数值位中间添加新位，正数都添0；负数原码添0，负数反，补码添1。

② 定点小数的符号扩展：在原符号位和数值位后面进添加新位，正数都添0；负数原，补码添0，负数反码添1。

5. 标志位生成

![image-20231122200302826](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311222003038.png)

### 2.2.5 定点数的移位运算

1. 原码的算数移位

原码的算数移位——符号位保持不变，仅对数值位进行移位。

右移：高位补0，低位舍弃。若舍弃的位等于0，则相当于÷2；若舍弃的位≠0，则会**丢失精度**。

左移：低位补0，高位舍弃。若舍弃的位等于0，则相当于x2；若舍弃的位≠0，则会出现**严重误差**

2. 反码的算数移位

正数：**正数**的反码与原码相同，因此对**正数反码的移位运算也和原码相同**。

负数：**负数**的反码数值位与原码相反，因此**负数反码的移位运算**规则如下：
右移：高位补**1**，低位舍弃。左移：低位补**1**，高位舍弃。

3. 补码的算数移位

正数：**正数**的补码与原码相同，因此对**正数的补码的移位运算也和原码相同**。
右移：高位补0，低位舍弃。左移：低位补0，高位舍弃。

负数：**负数**补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。

> **规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码**
>
> **负数补码**的算数移位规则如下：
>
> * 右移（同反码）：高位补**1**，低位舍弃
> * 左移（同原码）：低位补**0**，高位舍弃

4. 逻辑移位

左移：低位补0，高位舍弃。右移：高位补0，低位舍弃

可以把逻辑移位看作是对“无符号数”的算数移位。

5. 循环移位

​	① 不带进位位

​		用移出的位补上空缺

​	② 带进位位

​		溢出的位放到进位位，原进位位补上空缺

> 注意：由于原、反、补码的位数有限，因此某些时候算数移位不能精确等效乘法，除法。

### 2.2.6.1 原码的乘法运算

1. 原码一位乘法（手算模拟）

原码一位乘法：（机器字长n+1，数值部分占n位）

符号位通过**异或**确定：数值部分通过被乘数和乘数绝对值的**n轮加法，移位**完成，根据当前乘数中参与运算的位确定（ACC）加什么。

若当前运算位 **= 1，则（ACC）+[1 x 1]~原~**；若 **= 0；则（ACC）+ 0**。

每轮加法后ACC，MQ的内容统一**算数右移**

> * 乘数的符号位不参与运算，可以省略
> * 原码一位乘可以只用单符号位
> * 答题时最终结果最好写为原码机器数

![image-20231123172248447](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231722729.png)