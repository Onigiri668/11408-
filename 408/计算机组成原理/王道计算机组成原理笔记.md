# 第一章计算机系统概述

## 1.1 计算机发展历程

### 1.1.1 计算机硬件的发展

* **计算机系统 = 硬件 + 软件**
* **计算机硬件的发展：**
  * 第一代计算机：使用电子管
  * 第二代计算机：使用晶体管
  * 第三代计算机：使用较小规模的集成电路
  * 第四代计算机：使用较大规模的集成电路

**发展趋势：更微型，多用途；更巨型，超高速。**

> 晶体管之父：肖克利（1956年诺贝尔物理学奖得主）
>
> ​	1957年：“八叛徒“创立了仙童半导体
>
> ​	1959年：仙童半导体发明了”集成电路“
>
> ​	1968年：摩尔离开仙童，创立Intel
>
> ​	1969年：仙童销售部负责人桑德斯离开仙童，创立AMD

摩尔定律：集成电路上的晶体管数量每18个月就会翻一倍，所以每18个月计算机的处理效率就会提高一倍。

### 1.1.2 计算机软件的发展

计算机软件技术的发展，促进计算机系统的发展。

计算机语言的发展经历了面向机器的机器语言和汇编语言，面向问题的高级语言，其中高级语言的发展真正促进了软件的发展，它经历了从科学计算的**FORTRAN结构化程序设计的PASCAL**到**面向对象的C++和适应网络环境的JAVA**。

同时，直接影响计算机系统性能的提升的各种系统软件也有了长久的发展，特别是操作系统，如Windows ，UNIX，Linux等。

### 1.1.3 计算机的分类与发展方向

可以分为：

​	电子模拟计算机和电子数字计算机。

数字计算机又可以按照用途分为：

* 专用计算机和通用计算机
* 通用计算机又分为：巨型机，大型机，中型机，小型机，微型机和单片机

按照指令和数据流可以分为：

* 单指令流和单数据流系统（SISD），即传统给的冯·诺依曼体系结构。
* 单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统。
* 多指令流和单数据流系统（MISD），这种计算机**实际上不存在**。
* 多指令流和多数据流系统（MIMD），包括多处理器和计算机系统。

## 1.2 计算机系统结构

### 1.2.1 计算机系统的组成

计算机系统是由**硬件系统**和**软件系统**共同构建起来的。

### 1.2.2 计算机硬件的基本组成

1. 早期的冯·诺依曼机
   美籍匈牙利科学家冯·诺依曼最先提出”程序存储“的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为”现代计算机之父“。

> 什么是存储程序原理？按此原理，计算机应具有哪几大功能？
>
> **”程序存储“**：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的是地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即**按地址访问并顺序执行指令**。计算机按照此原理应具有5大功能：
>
> 数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能。



> 冯·诺依曼体系结构特点：
>
> * 计算机硬件系统由五大部件组成：存储器，运算器，控制器，输出设备，输入设备
> * 指令和数据以**同等地位**存于存储器，可按地址寻访
> * 指令和数据用二进制表示
> * 指令由操作码和地址码组成
> * 存储程序
> * 以**运算器**为中心
>
> 早起的冯·诺依曼机以运算器为中心，且是单处理机，**最根本的特征是采用”存储程序“原理**，基本工作方式是**控制流驱动方式**

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221522747.png)

2. 现代计算机的组织结构

![现代计算机的组织结构](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221523732.png)

3. 计算机的功能部件

主机：主存，运算器，控制器

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221523545.png)

五大部分：

1. 输入设备是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等
2. 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。
3. 存储器，存储器分为**主存储器**(内存储器，**CPU能直接访问**)和**辅助存储器**(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。
   **主存储器**的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式(**相联存储器**既可以既可以按照**地址寻址**，又可以按照**内容寻址**，为了与传统存储器区别，又称为**内容寻址的存储器**！
   主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221526852.png)
4. 运算器，是计算机的运算单元，用于算术运算和逻辑运算。运算器的核心单元是算术逻辑单元(ALU)
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221526892.png)
5. 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。
   ![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221527012.png)

一般将**运算器和控制器**集成到同一个芯片上，称为**中央处理器(CPU)**。**CPU和主存储器**共同构成**主机**，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。

CPU和主存之间通过**一组总线**相连，总线中有**地址、控制和数据3组信号线**。MAR中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；控制线中有读/写信号线，指出数据是从CPU写入主存还是从主存读出到CPU,根据是读操作还是写操作来控制将MDR中的数据是直接送到数据线上还是将数据线上的数据接收到MDR中。

### 1.2.3 计算机软件的分类

1. 系统软件和应用软件

计算机软件：一般分为系统软件和应用软件

* 系统软件包括操作系统，数据库管理系统，数据处理系统（比如编译器），分布式软件系统，网络软件系统，标准库系统，服务型系统（比如连接程序）。
* 应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序。

> 注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是有数据库，数据库管理系统，数据库管理员和应用程序构成。所以只能说它里面有系统软件，但并不能说它为系统软件。

2. 三个级别的语言
   1. 机器语言：又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。**机器语言是计算机唯一可以直接识别和执行的语言。**
   2. 汇编语言：汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个成为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。
   3. 高级语言：高级语言（如C，C++，Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

> 由高级语言转换到汇编语言的过程叫做**编译**，由汇编语言转换到机器语言的过程叫**汇编**，边翻译边执行叫做**解析**。

### 1.2.4 计算机的工作过程

**IR**存放当下欲执行的指令；**PC**存放下一条指令的地址；**MAR**存放欲访问的存储单元地址；**MDR**存放从存储单元取来的数据；**地址译码器**是主存的构成部分，不属于CPU；**地址寄存器**虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器。

关于CPU存取速度的比较：寄存器（CPU内部）> Cache（高速的SRAM）> 内存（RAM）

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221539734.png)

## 1.3 计算机性能指标

1. 机器字长

**计算机的位数**（机器字长），表示计算机进行一次整数运算即（定点整数运算）所能处理的二进制数据的位数。计算机字长通常选定为字节（8位）的整数倍，通常是2,4,8倍。不同的计算机字节可能不同。

> **机器字长，指令字长，存储字长的区别和联系是什么？**
>
> * 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
> * 指令字长：一个指令字中包含的二进制代码的位数。
> * **存储字长**：一个存储单元存储的二进制代码的长度。**等于MDR的位数**，他们都必须是字节的整数倍。
> * 数据字长：**数据总线一次能传送信息的位数**，它可以不等于MDR的位数。
>
> 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍。若指令字长等于存储字长，则取指周期等于机器周期。

2. 数据通路带宽

数据总线一次能传送信息的位数。

3. 主存容量

MAR的位数反应存储单元的个数，如MAR为16位，表示存储单元为2^16^=64K；若MDR为32位，则存储容量为2^16^x32。

> **2^10^ : K		2^20^ : M		2^30^ : G		2^40^ : T**

4. 运算速度

**吞吐量**：指系统在单位时间内处理请求的数据的数量；从用户观点看，它是**评价计算机系统性能的综合参数**。

相应时间：指从用户向计算机发送一个请求，到系统作出相应并获得所需结构的等待时间。

**CPU时钟周期**：通常为节拍脉冲或T周期，即主频的倒数，**它是CPU中最小的时间单位**，每一个动作至少需要1个时钟周期。

主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。

* CPU周期又称为机器周期，由多个时钟周期组成
* 指令周期 > CPU周期 > 时钟周期

**CPI（Clock cycle Per Instruction）：即执行一条指令所需的时钟周期数。**

CPU执行时间：指裕兴一个程序所花费的时间。

CPU执行时间 = CPU时钟周期数/主频 = （指令条数 x CPI）/ 主频

CPU的性能取决于三个要素：主频、CPI、指令条数

> IPS = 主频 / 平均CPI  ——每秒执行多少指令
>
> MIPS ——即每秒执行多少百万条指令
>
> MFLOPS = 浮点操作次数 / 执行时间 x 10^6^ ——即每秒执行多少百万次浮点运算
>
> GFLOPS = 浮点操作次数 / 执行时间 x 10^9^ ——即每秒执行多少十亿次浮点运算
>
> TFLOPS = 浮点操作次数 / 执行时间 x 10^12^ ——即每秒执行多少万亿次浮点运算

# 第二章 数据的表示与运算

## 2.1 数制与编码

### 2.1.1 进位计数指及其相互转化

进位计数值：

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221657969.png)

### 2.1.2 BCD码（Binary-code Decimal码）

![在这里插入图片描述](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221658766.png)

> 8421码注：
>
> 1. 每4个二进制位对应一个十进制位（由6个冗余状态）
> 2. 8,4,2,1分别对应每一位的权值
> 3. 0000~1001分别对应0-9，进行加法后若超出该范围则需+0110进行修正（强制向高位进1），若相加结果在合法范围内，无需修正
> 4. 8421码中1010~1111没有定义
>
> 2421码注：
>
> 2,4,2,1分别对应每一位的权值，表示0-4时最高位为0，表示5-9时最高位为1

### 2.1.3 无符号整数的表示和运算

1. 无符号整数的表示

各个数值位的”位权“ ：|2^7^|2^6^|2^5^|2^4^|2^3^|2^2^|2^1^|2^0^| 8bit寄存器

**无符号整数**：

* 全部二进制位都是数值位，没有符号位，第$i$位的位权是2^i-1^
* nbit无符号整数**表示范围为（0~2^n^-1）**，超出则**溢出**，意味着该计算机无法一次处理这么多
* 可以表示的**最小数：全0**，可以表示的**最大数：全1**

2. 无符号整数的加法运算

计算机硬件如何做无符号整数的**加法**：从最低位开始，**按位相加**，并往更高位**进位**。

3. 无符号整数的减法运算

计算机硬件如何做无符号整数的减法：

​	① “被减数”不变，**“减数”**==全部位==**按位取反，末位+1，减法变加法**

​	② 从最低位开始，**按位相加**，并往更高位**进位**

### 2.1.4 带符号整数的表示和运算

1. 带符号整数的表示

   1. 原码表示

   **原码**： ①  符号位“0/1”对应"正/负"，剩余的数值位表示真值和绝对值

   ​            ② 若机器字长n+1位，带符号整数的原码表示范围：**-(2^n^-1) ≤ x ≤ 2^n^-1**

   ​	    ③ 真值0有两种形式：**+0**和**-0** ， [+0]~原~ = 0.0000000 ； [-0] = 1.0000000；

   ​		常见的书面写法：x = -19        [x]~原~ = 1.0010011

   ​		若未指明机器字长，也可写为：[x]~原~ = 1.10011

   ​		**原码**的缺点：**符号位不能参与运算**，需要设计复杂的硬件电路才能处理

   ​		用补码表示真值——符号位可参与运算

   2. 原码 → 反码 → 补码的转换（机算）

   **正数**：   |原码| ←----------------不变----------------→ |反码|  ←----------------不变----------------→ |补码|

   **负数**：   |原码| ←---**符号位不变数值位取反**----→ |反码|  ------------------**末位+1**--------------→ |补码|

   3. 原码、补码快速转换技巧（手算）

   **正数**：   |原码| ←------------------------------------------不变------------------------------------------→|补码|

   **负数**：   |原码| ←-----**从右往左找到第一个1，这个1左边的所有“数值位”按位取反**-----→|补码|

   4. 补码的加法运算

   **符号位0正1负**      |符|~~2^6^~~|~~2^5^~~|~~2^4^~~|~~2^3^~~|~~2^2^~~|~~2^1^~~|~~2^0^~~|      **补码数值位不能解读为“位权”**

   计算机硬件如何做补码的加法：从最低位开始，**按位相加（符号位参与运算）**，并往更高位**进位**。

   5. 补码的减法运算

   [A]~补~ - [B]~补~ = [A]~补~ + [-B]~补~

   ​		|[B]~补~| ←------**全部位按位取反，末位+1**------→ |[-B]~补~|

   计算机硬件如何做带符号数补码的减法：

   ① “被减数”不变，**“减数”全部位按位取反，末位+1**，减法变加法

   ② 从最低位开始，**按位相加**，并往更高位**进位**

   |       n+1 bit        |        合法表示范围        |  最大的数  |  最小的数   |                   真值0的表示                   |
   | :------------------: | :------------------------: | :--------: | :---------: | :---------------------------------------------: |
   |   带符号整数：原码   | -(2^n^ - 1) ≤ x ≤ 2^n^ - 1 |  2^n^ - 1  | -(2^n^ - 1) | [+0]~原~ = 0.000...00<br />[-0]~原~ = 1.000..00 |
   |   带符号整数：反码   | -(2^n^ - 1) ≤ x ≤ 2^n^ - 1 |  2^n^ - 1  | -(2^n^ - 1) | [+0]~反~ = 0.000...00<br />[-0]~反~ = 1.000..00 |
   | 带符号整数：**补码** |  **-2^n^** ≤ x ≤ 2^n^ - 1  |  2^n^ - 1  |    -2^n^    | [0]~补~ = 0.000...00<br />**真值0只有一种补码** |
   |      无符号整数      |     0 ≤ x ≤ 2^n+1^ - 1     | 2^n+1^ - 1 |      0      |                   0.000...000                   |

   原码和反码的合法表示范围完全相同，都有两种方法表示真值0

   **补码**的合法表示范围比原码**多一个负数**，只有一种方法表示真值0

   6. 移码

   **移码**：补码的基础上将**符号位取反**。**注意：移码只能用于表示整数**

### 2.1.7 定点小数

1. 原码

定点小数

​	|X~0~|     |X~1~|X~2~|...|X~n~|			|符|2^-1^|2^-2^|2^-3^|2^-4^|2^-5^|2^-6^|2^-7^|

​    符号位  ↑       数值部分

​	小数点位置（隐含）

**原码**：符号位“0 / 1" 对应”正 / 负“

![image-20231122190224157](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221902376.png)

2. 定点小数的加/减法运算

对两个顶点小数A，B进行加法/减法时，需要先转换为补码

计算机硬件如何做**定点小数补码**的加法：从最低位开始，**按位相加（符号位参与运算）**，并往更高位**进位**

计算机硬件如何做**定点小数补码**的减法：

​	① ”被减数“不变，”减数”全部位按位取反，末位+1，减法变加法

​	② 从最低位开始，**按位相加**，并往更高位**进位**

| n+1 bit            | 合法表示范围                 | 最大的数  | 最小的数     | 真值0的表示                                     |
| ------------------ | ---------------------------- | --------- | ------------ | ----------------------------------------------- |
| 定点小数：原码     | -(1 - 2^-n^) ≤ x ≤ 1 - 2^-n^ | 1 - 2^-n^ | -(1 - 2^-n^) |                                                 |
| 定点小数：反码     | -(1 - 2^-n^) ≤ x ≤ 1 - 2^-n^ | 1 - 2^-n^ | -(1 - 2^-n^) |                                                 |
| 定点小数：**补码** | **-1** ≤ x ≤ 1 - 2^-n^       | 1 - 2^-n^ | -1           | **[0]~补~ = 0.000...00<br />真值0只有一种补码** |

### 2.2.0 奇偶校验码

校验码：任意两个码字之间最少变化的二进制位数称为码距，码距大于等于2的数据校验码开始具有检错的能力。**码距越大，检错，纠错能力越强**。就校验码的码距等于2，可以检测出以为错误（或技术位错误），但不能确定出错的位置，也不能检测出偶数位错误，**仅靠增加奇偶校验位的位数不能提高正确性，还要考虑码距。**

具有检，纠错能力的数据校验码的实现原理：在编码中，除合法码字外，再加入一些非法码字，当某个合法码字出现错误时，就变为非法码字。合理安排非法码字的数量和编码规则就能达到纠错的目的。

奇偶校验码：

* 奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数
* 偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数

> 奇偶校验码的码距d = 2 ， 仅能检测出奇数位错误，无纠错能力。
>
> 偶校验的硬件实现：各信息进行异或（模2加）运算，得到的结果即为偶校验位。

### 2.2.1 电路的基本原理，加法器设计

1. 算数逻辑单元（ALU）

![image-20231122191739225](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221917416.png)

2. 电路基础知识

​	① 逻辑运算

![image-20231122191949674](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221919803.png)

![image-20231122192247114](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221922264.png)

3. 加法器的实现

​	① 一位全加器的设计

![image-20231122192656558](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221926734.png)

​	② 串行加法器

![image-20231122193031333](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221930480.png)

​	③ 并行加法器

![image-20231122193507574](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221935724.png)

### 2.2.2 并行进位加法器

![image-20231122193654716](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221936849.png)

### 2.2.3 补码加减运算器

![image-20231122193955080](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221939223.png)

### 2.2.4 加减运算和溢出判断

1. 原码

   1. 加法

   同号相加：数值部分 = 被加数，加数的绝对值进行相加，符号位不变。

   异号相加：数值部分 = 被加数，加数中绝对值更大的减绝对值更小的。符号位于绝对值更大的数相同。

   2. 减法

   将减数取负，转变为加法。

2. 补码

对于补码来说，无论加法还是减法，**最后都会转变成加法**，由加法器实现运算，符号位也参与运算。

3. 溢出判断

![image-20231122194409944](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311221944123.png)

* 只有“正数+正数”才会**上溢**——正+正=负
* 只有“负数+负数”才会下溢——负+负=正

方法一：采用一位符号位

设A的符号位为A~S~，B的符号位为B~S~，运算结果的符号为S~S~，则溢出逻辑表达式为：
$$
V = A_SB_S\overline{ S_S} + \overline{A_SB_S}S_S
$$
若V = 0，表示无溢出；若V = 1，表示有溢出

方法二：**采用一位符号位，根据数据位进位情况判断溢出**

|      | 符号位的进位C~S~ | 最高数值位的进位C~1~ |
| ---- | ---------------- | -------------------- |
| 上溢 | 0                | 1                    |
| 下溢 | 1                | 0                    |

即：C~S~与C~1~不相同时有溢出

方法三：**采用双符号位**

正数符号为00，负数符号为11

记两个符号位为S~S1~，S~S2~，则V = S~S1~ ⊕ S~S2~

若V = 0 表示无溢出；若V = 1，表示有溢出

双符号位补码又称：模4补码；单符号位补码又称：模2补码

> 实际存储时值存储1个符号位，运算时会复制一个符号位

4. 符号扩展

① 定点整数的符号扩展：在原符号位和数值位中间添加新位，正数都添0；负数原码添0，负数反，补码添1。

② 定点小数的符号扩展：在原符号位和数值位后面进添加新位，正数都添0；负数原，补码添0，负数反码添1。

5. 标志位生成

![image-20231122200302826](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311222003038.png)

### 2.2.5 定点数的移位运算

1. 原码的算数移位

原码的算数移位——符号位保持不变，仅对数值位进行移位。

右移：高位补0，低位舍弃。若舍弃的位等于0，则相当于÷2；若舍弃的位≠0，则会**丢失精度**。

左移：低位补0，高位舍弃。若舍弃的位等于0，则相当于x2；若舍弃的位≠0，则会出现**严重误差**

2. 反码的算数移位

正数：**正数**的反码与原码相同，因此对**正数反码的移位运算也和原码相同**。

负数：**负数**的反码数值位与原码相反，因此**负数反码的移位运算**规则如下：
右移：高位补**1**，低位舍弃。左移：低位补**1**，高位舍弃。

3. 补码的算数移位

正数：**正数**的补码与原码相同，因此对**正数的补码的移位运算也和原码相同**。
右移：高位补0，低位舍弃。左移：低位补0，高位舍弃。

负数：**负数**补码=反码末位+1，导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。

> **规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码**
>
> **负数补码**的算数移位规则如下：
>
> * 右移（同反码）：高位补**1**，低位舍弃
> * 左移（同原码）：低位补**0**，高位舍弃

4. 逻辑移位

左移：低位补0，高位舍弃。右移：高位补0，低位舍弃

可以把逻辑移位看作是对“无符号数”的算数移位。

5. 循环移位

​	① 不带进位位

​		用移出的位补上空缺

​	② 带进位位

​		溢出的位放到进位位，原进位位补上空缺

> 注意：由于原、反、补码的位数有限，因此某些时候算数移位不能精确等效乘法，除法。

### 2.2.6.1 原码的乘法运算

1. 原码一位乘法（手算模拟）

原码一位乘法：（机器字长n+1，数值部分占n位）

符号位通过**异或**确定：数值部分通过被乘数和乘数绝对值的**n轮加法，移位**完成，根据当前乘数中参与运算的位确定（ACC）加什么。

若当前运算位 **= 1，则（ACC）+[1 x 1]~原~**；若 **= 0；则（ACC）+ 0**。

每轮加法后ACC，MQ的内容统一**算数右移**

> * 乘数的符号位不参与运算，可以省略
> * 原码一位乘可以只用单符号位
> * 答题时最终结果最好写为原码机器数

![image-20231123172248447](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231722729.png)

### 2.2.6.2 补码的乘法运算

![image-20231123172553898](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231725167.png)

![image-20231123172633354](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231726533.png)

![image-20231123172719059](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231727253.png)

### 2.2.7.1 原码的除法运算

1. 原码除法：恢复余数法（手算）

![image-20231123172855402](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231728616.png)

2. 原码除法：加减交替法

符号位于数值位分开处理

![image-20231123173018141](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231730315.png)

> 恢复余数法：当余数为负时商0，并+|除数|，再左移再 - |除数|
>
> 加减交替法：当余数为负时商0，并左移，再+|除数|
>
> 加/减n + 1次，每次加减确定一位商；左移n次（最后一次加减完不移位）最终可能还要再多一次加

### 2.2.7.2 补码的除法运算

补码除法：加减交替法

![image-20231123173300062](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231733247.png)

### 2.2.8 C语言类型转换

强制类型转换

> 注：C语言中定点整数是用”补码“存储的
>
> 无符号数于有符号数：不改变数据内容，改变解析方式。
>
> 长整数变短整数：高位截断，保留低位。
>
> 短整数变长整数：符号扩展。

### 2.2.9 数据的存储和排列

1. 大小端模式

![image-20231123173521989](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231735209.png)

2. 边界对齐

现代计算机通常是按字节编制，即每个字节对应1个地址

通常也支持按字，按半字，按字节寻址

假设存储字长为32位，则1个字 = 32bit，半字 = 16bit ，每次访存只能读/写1个字

![image-20231123173657199](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231736362.png)

### 2.3.1 浮点数的表示

1. 浮点数的表示

![image-20231123173744086](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231738024.png)

浮点数的真值：$N=r^E*M$ ——**阶码为底，通常为2**

阶码：常用补码或移码表示的定点整数
尾数：常用原码或补码表示的定点小数

阶码E反映浮点数的表示范围及小数点的实际位置；尾数M的数值部分的位数n反映浮点数的精度

2. 浮点数尾数的规格化

规格化浮点数：规定**尾数的最高数值位必须是一个有效值**

左规：当浮点数运算的结果为非规格化时要进行规格化处理，将**尾数算数左移一位，阶码减1**==（通过算数左移，阶码减1来规格化）==

右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将**尾数算数右移一位，阶码+1**==（通过算数右移，阶码加1来规格化）==

> 注：采用”双符号位“，当溢出发生时，可以挽救。更高的符号位是正确的符号位。

3. 规格化浮点数的特点

   1. 用原码表示的尾数进行规格化：

   正数为$0.1xx...x$的形式，其最大值表示为$0.11...1$；最小值表示为$0.10...0$。尾数的表示范围为$\frac{1}{2} ≤ M ≤ (1 - 2^{-n})$

   负数为$1.1xx...x$的形式，其最大值表示为$1.10...0$；最小值表示为$1.11...1$。尾数的表示范围为$-(1-2^{-n}) ≤ M ≤ -\frac{1}{2}$

   > 规格化的原码尾数，最高数值位一定是1

   2. 用补码表示的尾数进行规格化：

   正数为$0.1xx...x$的形式，其最大值表示为$0.11...1$；最小值表示为$0.10...0$。尾数的表示范围为$\frac{1}{2} ≤ M ≤ (1 - 2^{-n})$

   负数为$1.0xx...x$的形式，其最大值表示为$1.01...1$；最小值表示为$1.00...0$。尾数的表示范围为$-1 ≤ M ≤ -(\frac{1}{2}+2^{-n})$

   > 规格化的补码尾数，符号位与最高数值位一定相反

   ![image-20231123175247714](https://image-1304558852.cos.ap-beijing.myqcloud.com/202311231752972.png)

   > 注：补码的算数左移，低位补0；补码算数右移，高位补1

### 2.3.2 IEEE 754

![image-20231211200019588](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112000470.png)

![image-20231211200152512](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112001663.png)

由浮点数确定真值（阶码不是全0，也不是全1）：

* 根据“某浮点数”确定数符，阶码，尾数的分布
* 确定尾数1.M（注意补充最高的隐含位1）
* 确定阶码的真值 = 移码 - 偏置值（可将移码看做无符号数，用无符号数的值减去偏置值）
* $ (-1)^s* 1.M * 2^{E-偏置值}$

只有$1 ≤ E ≤ 254$时，$真值=(-1)^s*1.M*2^{E-127}$

当**阶码E全为0，尾数M不全为0时**，表示**非规格化小数**
当**阶码E全为0，尾数M全为0时**，表示**真值±0**
当**阶码E全为1，尾数M全为0时**，表示**无穷大±∞**
当**阶码E全为1，尾数M不全为0时**，表示**非数值“NaN”（Not a Number）**

### 2.3.3 浮点数的运算

1. 浮点数的加减运算

​	浮点数加减运算步骤：

​	① 对阶	② 尾数加减	③ 规格化	④ 舍入	⑤ 判溢出

例：已知十进制数 $X = -5/256 ， Y=+59/1024$，按机器补码浮点数运算规则计算$X - Y$，结果用二进制表示，浮点数格式如下：阶符取2位，阶码取3位，数符取2位，尾数取9位。

> 用补码表示阶码和尾数
>
> 0. 转换格式
>
> $5D = 101B，\frac{1}{256}=2^{-8}→X=-101*2^{-8}=-0.101*2^{-5}=-0.101*2^{-101}$
>
> $59D = 111011B，\frac{1}{1024}=2^{-10}→Y=+111011*2^{-10}=+0.111011*2^{-4}=+0.111011*2^{-100}$
>
> $X : 11011,11.011000000	$		$Y:11100,00.111011000$
>
> 1. 对阶：**使两个数的阶码相等，小阶向大阶看齐，尾数每右移一位，阶码加1**
>
>    ① 求阶差：$[△E]_{补} = 11011+00100=11111，知△E=-1$
>
>    ② 对阶：$X:11011,11.011000000→11100,11.101100000$
>
> 2. 尾数加减
>
>    $-Y:11100,11.000101000$
>
>    $X-Y:11100,10.110001000$
>
> 3. 规格化
>
>    $X-Y:11100,10.110001000→11101,11.011000100$
>
> 4. 舍入
>
>    无舍入
>
> 5. 判溢出
>
>    常阶码，无溢出，结果真值为$2^{-3}*(-0.1001111)_2$

2. 浮点数的加减运算一舍入

​	“0”舍“1”入法：类似于十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1.这样做可能会使尾数又溢出，此时需再做一次右规。

​	恒置”1“法：尾数右移时，不论丢掉的最高数值位是”1“还是”0“，都使右移后的尾数末位横置”1“。这种方法同样有使尾数变大和变小的两种可能。

3. C强制类型转换

​	无损：

char → int → long → double

float → double

​	有损：

int → float：可能会损失精度（float尾数的数值位有1+23位）

float → int：可能会溢出，也可能会损失精度（如小数转整数）

# 第三章 存储系统

## 3.1 存储系统基本概念

1. 存储器的层次化结构

![image-20231211205557990](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112055290.png)

2. 存储器的分类一层次

![image-20231211205723490](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112057731.png)

3. 存储器的分类一存取方式

随机存取存储器（Random Access Memory，RAM）：读写任何一个存储单元所需时间都相同，与存储单元所在的物理位置无关。

串行访问存储器：读写某个存储单元所需时间与存储单元的物理位置有关。

顺序存取存储器（Sequential Access Memory，SAM）：读写一个存储单元所需时间取决于存储单元所在的物理位置

直接存取存储器（Direct Access Memory，DAM）：既有随机存储特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取。

相联存储器（Associative Memory）：即可以按内容访问的存储器（Content Addressed Memory，CAM）可以按照内容检索到存储位置进行读写，”快表“就是一种相联存储器。

4. 存储器的分类一信息的可更改性

读写存储器（Read/write Memory）：即可读，也可写。

只读存储器（Read Only Memory）：只能读，不能写。

5. 存储器的分类一信息的可保存性

断电后，存储信息消失的存储器一一易失性存储器（主存，Cache）

断电后，存储信息依然保存的存储器一一非易失性存储器（磁盘，光盘）

信息读出后，原存储信息被破坏一一破坏性读出（如DRAM芯片）

信息读出后，原存储信息不被破坏一一非破坏性读出（如SRAM芯片）

6. 存储器的性能指标

​	1）存储容量：存储字数 X 字长（如1M x 8位）  ←MDR位数反应存储字长

​	2）单位成本：每位价格 = 总成本 / 总容量

​	3）存储速度：**数据传输率** = 数据的宽度 / 存储周期 ←数据的宽度即存储字长

![image-20231211210911794](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112109105.png)

> ① 存取时间（Ta）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。
>
> ② 存取周期（Tm）：存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔。
>
> 主存带宽（BM）：**主存带宽**又称**数据传输率**，表示每秒从主存进出信息的最大数量，单位为字/秒，字节/秒（B/s）或位/秒（b/s）

### 3.2.1 主存储器的基本组成

1. 基本的半导体元件及原理

![image-20231211211423543](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112114790.png)

2. 存储器芯片的基本原理

![image-20231211211608412](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112116633.png)

![image-20231211211638686](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112116920.png)

3. 寻址

现代计算机通常按字节编址（每个字节），即每个字节对应一个地址

按字节寻址，按字寻址，按半字寻址，按双字寻址。

### 3.2.2 SRAM和DRAM

1. DRAM v.s SRAM

| 类型特点                 | SRAM（静态RAM）        | DRAM（动态RAM）          |
| ------------------------ | ---------------------- | ------------------------ |
| 存储信息                 | 触发器                 | 电容                     |
| 破坏性读出               | 非                     | 是                       |
| 读出后需要重写？（再生） | 不用                   | 需要                     |
| 运行速度                 | 快                     | 慢                       |
| 集成度                   | 低                     | 高                       |
| 发热量                   | 大                     | 小                       |
| 存储成本                 | 高                     | 低                       |
| 易失/非易失性存储器？    | 易失（断电后信息消失） | 易失（断电后信息消失）   |
| 需要”刷新“               | 不需要                 | 需要（分散，集中，异步） |
| 送行列地址               | 同时送                 | 分两次送                 |
|                          | **常用作Cache**        | **常用作主存**           |

2. DRAM的刷新

① 多久需要刷新一次？

​	刷新周期：一般为2ms

② 每次刷新多少存储单元？

​	以行为单位，每次刷新一行存储单元

​     为什么用行列地址？ 

​	减少选通线的数量

③ 如何刷新？

​	有硬件支持，读出一行信息后重新写入，占用1个读/写周期

④ 在什么时候刷新？

![image-20231211212503129](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112125404.png)

3. DRAM的地址线复用技术

​	行，列地址分两次送，可使地址线更少，芯片引脚更少

### 3.2.3 只读存储器ROM

1. 了解各种ROM

MROM（Mask Read-Only Memory）：掩模式只读存储器

​	厂家按客户需求，在芯片生产过程中直接写入信息，之后**任何人不可重写**（只能读出）可靠性高，灵活性差，生产周期长，只适合批量定制。

PROM（Programmable Read-Only Memory）：可编程只读存储器

​	用户可用专门的PROM写入器写入信息，写**一次之后就不可更改**。

EPROM（Erasable Programmable Read-Only Memory）：可擦除可编程只读存储器

​	允许用户写入信息，之后用某种方法擦除数据，**可进行多次重写**。

UVEPROM（Ultraviolet rays）：用紫外线照射8~20分钟，擦除所有信息

EEPROM也常记为E^2^PROM，第一个E是Electrically：可用”电擦除“擦除特定字

Flash Memory：闪速存储器（注：U盘，SD卡就是闪存）

​	在EEPROM基础上发展而来，断电后也能保存信息，且**可进行多次快速擦除重写**。

​	注意：由于闪存需要先擦除再写入，因此，闪存的”写“速度要比”读“速度更慢。

SSD（Solid State Drives）：固态硬盘

​	由控制单元+存储单元（Flash芯片）构成，与闪速存储器的核心区别在于控制单元不一样，但存储介质都类似，**可进行多次快速擦除重写**。SSD速度快，功耗低，价格高。目前个人电脑上常用SSD取代传统的机械硬盘。

> 注：很多ROM芯片虽然名字是”Read-Only“，但很多ROM也可以写。
>
> 闪存的写速度一般比读速度更慢，因为写入前要先擦除。
>
> RAM芯片是易失性的，ROM芯片是非易失性的。很多ROM也具有”随机存取“的特性。

### ~~3.2.4 多模块存储器~~

1. 多体并行存储器

![image-20231211214138357](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312112141673.png)

2. 应该取几个”体“

采用”流水线“的方式并行存取（宏观上并行，微观上串行）

宏观上，一个存储周期内，m体交叉存储器可以提供的数量为单个模块的m倍。

存储周期为T，存取时间为r，为了使流水线不间断，应保证模块数m ≥ T / r

存储周期为T，总线传输周期为r，为了使流水线不间断，应保证模块数 m ≥ T / r

3. 多模块存储器

单体多字存储器：每次读出m个连续的字

​			       总线宽度也要扩展为m个字

多体并行存储器：高位交叉编址

​			       低位交叉编址

高位交叉编址：理论上多个存储体可以被并行访问，但是由于通常会连续访问，因此实际效果相当于单纯的扩容

低位交叉编址：当存储模块数m ≥ T / r 时，可使流水线不间断

​			   每个存储周期内科读写地址连续的m个字

​			   微观上，m个模块被串行访问；宏观上，每个存取周期内所有模块被并行访问

### 3.4.1 磁盘存储器

1. 外存储器

计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器，所谓”磁表面存储“，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器，磁带存储器和磁鼓存储器均属于磁表面存储器。

磁表面存储器的优点：

* 存储容量大，位价格低
* 记录介质可以重复使用
* 记录信息可以长期保存而不丢失，甚至可以脱机存档
* 非破坏性读出时不需要再生

磁表面存储器的缺点：

* 存取速度慢
* 机械结构复杂
* 对工作环境要求高

2. 磁盘存储器

1）磁盘设备的组成

① 存储区域

​	一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取

​	磁头数（Heads）：

​	即记录面数，表示硬盘总共有多少个磁头，磁头用于读/写入盘片上记录面的信息，一个记录面对应一个磁头。

​	柱面数（Cylinders）：

​	表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面。

​	扇区数（Sectors）：

​	表示每一条磁道上有多少个扇区。

② 硬盘存储器

​	硬盘存储器由磁盘驱动器，磁盘控制器和盘片组成。

​	磁盘驱动器：核心部件是磁头组件和盘片组件，温切斯特盘是一种可移动头固定盘片的硬盘存储器。

​	磁盘控制器：是硬盘存储器和主机的结构，主流的标准有IDE，SCSI，SATA等。

2）磁盘的性能指标

① 磁盘的容量：一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。

​	非格式化容量是指磁记录表面可以利用的磁化单元总数。

​	格式化容量是指按照某种特定的记录格式所能存储信息的总量。

② 记录密度：记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度，位密度和面密度表示。

​	道密度是沿磁盘半径方向单位长度上的磁道数。

​	位密度是磁道单位长度上能记录的二进制代码位数。

​	面密度是位密度和道密度的乘积。

③ 平均存取时间：

​	平均存取时间 = 寻道时间（磁头移动到目的磁道）+ 旋转延迟时间（磁头定位到所在扇区） +  传输时间（传输数据所花费的时间）

④ 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。

​	假设磁盘转数位r（转/秒），每条磁道容量为N个字节，则数据传输率为D~r~ = rN

> 注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，每个磁道的位密度都不同。

3）磁盘地址

主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示：

![image-20231212151623483](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121516811.png)

若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道，16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码：

![image-20231212151817649](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121518950.png)

4）硬盘的工作过程

硬盘的主要操作是寻址，读盘，写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻即读又写，也不能在同一时刻读两组数据或写两组数据。

3. 磁盘阵列

RAID（Redundant Array of Inexpensive Disks，廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储，并行访问，具有更好的存储性能，可靠性和安全性。

RAID的分级如下所示。在RAID1 ~ RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。

RAID0：无冗余和无校验的磁盘阵列。
逻辑上相邻的两个扇区在物理上存到两个磁盘。

RAID1：镜像磁盘阵列
存两份数据

RAID2：采用纠错的海明码的磁盘阵列
逻辑上连续的几个bit物理上分散存储在各个盘中，4bit信息位+3bit海明校验位一一可纠正一位错。

RAID3：位交叉奇偶校验的磁盘阵列。

RAID4：块交叉奇偶校验的磁盘阵列。

RAID5：无独立校验的奇偶校验磁盘阵列。

> RAID0把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存储速度，但RAID0没有容错能力。
>
> RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可以从另一磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。
>
> RAID通过使用多个磁盘，提高了传输率，通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量，通过镜像功能，可以提高安全可靠性，通过数据校验，可以提供容错能力。

### 3.4.2 固态硬盘SSD

1. 原理

基于闪存技术（Flash Memory），属于电可擦除ROM，即EEPROM。

2. 组成

闪存翻译层：负责翻译逻辑块号，找到对应页（Page）

存储介质：多个闪存芯片（Flash Chip）每一个芯片包含多个块（block）每一个块包含多个页（page）

3. 读写性能特性

* 以页为单位读/写 相当于磁盘的”扇区“
* 以块为单位”擦除“，擦干净的块，其中的每页都可以写一次，读无限次
* 支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址
* 读快，写慢。需要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页。

4. 与机械硬盘相比的特点

​	① SSD读写速度快，随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟。

​	② SSD安静无噪音，耐摔抗震，能耗低，造价更贵。

​	③ SSD的一个”块“被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉。

5. 磨损均衡技术

思想：将”擦除“平均分布在各个块上，以提升使用寿命。

动态磨损均衡：

​	写入数据时，有限选择累计擦除次数少的心闪存块。

静态磨损均衡：

​	SSD检测并自动进行数据分配，迁移，让老旧的闪存块承担以读为主的存储任务，让较新的闪存块承担更多的写任务。

### 3.5.1 Cache的基本概念和原理

1. 工作原理

将某些主存块复制到Cache中，缓和CPU与主存之间的速度矛盾。

2. 局部性原理

① 时间局部性

​	现在访问的地址，不久之后也可能被再次访问。

② 空间局部性

​	现在访问的地址，其附近的地址也很可能即将被访问。

3. 性能分析

Cache命中率：CPU欲访问的信息已在Cache中的比率。

先访问Cache，发现未命中再访问主存。
同时访问Cache和主存，若Cache命中则停止访问主存。

4. 其他概念

* 主存与Cache之间以”块“为单位进行数据交换。
* 主存的”块“又叫”页/页框/页面“；Cache的”块“又叫”行“。
* 主存地址可拆分为（主存块号，块内地址）的形式

> 每次访问的主存块，一定会被立即调入Cache

### 3.5.2 Cache和主存的映射方式

1. Cache中存储的信息

有效位（011）+ 标记 + 整块数据

其中”标记“用用于指明对应的内存块，不同映射方式，”标记“的位数不同。

2. 全相联映射

* 主存块可以放到Cache的任意位置
* 主存地址结构：标记（整个主存块号） + 块内地址
* 优点：Cache存储空间利用充分，命中率高
* 缺点：查找”标记“最慢，又可能需要对比所有行的标记

3. 直接映射

* 主存块只能放到特定的某个Cache行，行号 = 主存号 % 总行数
* 主存地址结构：标记（主存块号前几位）+ 行号（主存号末几位）+ 块内地址
* 优点：对于任意一个地址，只需对比一个”标记“，速度最快
* 缺点：Cache存储空间利用不充分，命中率低

4. 组相联映射

* 主存块可以放到特定分组中的任意位置，所属组号 = 主存块号 % 总组数
* 主存地址结构：标记（主存块号前几位）+ 组号（主存块号末几位）+ 块内地址
* 优点：另外两种方式的折中，综合效果较好
* 术语：n路组相联映射一一每n个Cache行为一组

### 3.5.3 Cache替换算法

1. **随机算法**（**RAND**，Random）：若Cache已满，则随机选择一块替换

实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定。

2. **先进先出算法**（**FIFO**，First In First Out）：若Cache已满，则替换最先被调入Cache的块

实现简单，最开始按#0 #1 #2 #3 放入Cache，之后轮流替换#0 #1 #2 #3

FIFO依然没考虑局部性原理，最先被调入Cache的块也有可能是被频繁访问的。

抖动现象：频繁的换入换出现象（刚被替换的块很快又被调入）

3. **近期最少使用算法**（**LRU**，least Recently Used）：为每一个Cache块设置一个”计数器“，用于记录每个Cache块已经有多久没被访问了。当Cache满后替换”计数器“最大的。

* 命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变
* 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1
* 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块计数器置0，其余全加1

> 基于”局部性原理“，近期被访问过的主存块，在不久的将来也很有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果优秀，Cache命中率高。
>
> 若被频繁访问的主存块数量 > Cache行的数量，则有可能发生”抖动“

4. **最不经常使用算法**（**LFU**，Least Frequently Used）：为每一个Cache块设置一个”计数器“，用于记录每个Cache块被访问过几次。当Cache满后替换”计数器“最小的。

> 新调入的块计数器 = 0，之后每被访问一次计数器+1。需要替换时，选择计数器最小的一行。
>
> 曾经被经常访问的主存块在未来不一定会用到，并没有很好地遵循局部性原理，因此实际运行效果不如LRU。

### 3.5.4 Cache写策略

1. 写命中

① 全写法（写直通法，write-through）

当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲。

② 写回法（write-allocate）

当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。

2. 写不命中

① 写分配法（write-allocate）

当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改。通常搭配写回法使用。

② 非写分配法（not-write-allocate）

当CPU对Cache写不命中时只写入主存，不调入Cache。通常搭配全写法使用。

3. 多级Cache

现代计算机通常采用多级Cache结构，各级Cache间常用”全写法+非写分配法“，Cache和主存间常采用”写回法+写分配法“

### 3.6.1 页式存储器

1. 页式存储

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121639592.png" alt="image-20231212163950175" style="zoom:50%;" />

页式存储系统：一个程序（进程在逻辑上被分为若干个大小相等的”页面“，”页面“大小与”块“的大小相同）。每个页面可以离散地放入不同的主存块中。

2. 虚地址 vs 实地址

逻辑地址（虚地址）：程序员视角看到的地址

物理地址（实地址）：实际在主存中的地址

逻辑地址：<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121643758.png" alt="image-20231212164304430" style="zoom:50%;" />

物理地址：<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121643597.png" alt="image-20231212164328299" style="zoom:50%;" />

3. 页表：逻辑页号 → 主存块号

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121644850.png" alt="image-20231212164445587" style="zoom:50%;algin:left" />

CPU执行的机器指令中，使用的是“逻辑地址”，因此需要通过“页表”将逻辑地址转为物理地址。

页表的作用：记录了每个逻辑页面存放在哪个主存块中。

4. 地址变换过程（增加TLB）

![image-20231212164953027](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121649294.png)

# 第四章 指令系统

### 4.1.1 指令格式

1. 指令的定义

指令（又称机器指令）：是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的**指令系统**，也称为**指令集**。

> 注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

2. 指令格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常要包括操作码字段和地址码字段两部分：<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121653997.png" alt="image-20231212165335864" style="zoom:50%;" />

3. 零地址指令（OP）

① 不需要操作数，如空操作，停机，关中断等指令。

② 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。

4. 一地址指令

​	|OP|A~1~|

① 只需要单操作数，如加1，减1，取反，求补等。

​	指令含义：OP（A~1~）→ A~1~

② 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC）

​	指令含义：（ACC）OP（A~1~）→ ACC

> 注：A~1~指某个主存地址，（A~1~）表示A~1~所指向的地址中的内容。

5. 二，三地址指令

① 二地址指令：	|OP|A~1~（目的操作数）|A~2~（源操作数）|

常用于需要两个操作数的算数运算，逻辑运算相关指令。

​	指令含义：（A~1~）OP（A~2~）→ A~1~

完成一条指令需要访存4次，取指→读A~1~→读A~2~→写A~1~

② 三地址指令：	|OP|A~1~|A~2~|A~3~（结果）|

常用于需要两个操作数的算数运算，逻辑运算相关指令

​	指令含义：（A~1~）OP（A~2~）→ A~3~

完成一条指令需要访存4次，取指→读A~1~→读A~2~→写A~3~

6. 四地址指令：

​	|OP|A~1~|A~2~|A~3~（结果）|A~4~（下址）|

​	指令含义：（A~1~）OP（A~2~）→ A~3~，A~4~ = 下一条将要执行指令的地址

​	正常情况下：取指令之后PC + 1，指向下一条指令

​	四地址指令：执行指令后，将PC的值修改为A~4~所指地址

7. 指令一按指令长度分类

指令字长：一条指令的总长度（可能会变）

机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）

存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）

定长指令字结构：指令系统中所有指令的长度都相等

变长指令字结构：指令系统中各种指令的长度不相等

8. 指令一按操作码长度分类

定长操作码：指令系统中所有指令的操作码长度都相同

控制器的译码电路设计简单，但灵活性较低。

可变长操作码：指令系统中各指令的操作码长度可变

控制器的译码电路设计复杂，但灵活性较高。

9. 指令一按操作类型分类

① 数据传送

​	LOAD 作用：把存储器中的数据放到寄存器中

​	STORE 作用：把寄存器中的数据放到存储器中

② 算数逻辑操作

​	算数：加，减，乘，除，增1，减1，求补，浮点运算，十进制运算

​	逻辑：与，或，非，异或，位操作，位测试，位清除，位求反

③ 移位操作

​	算数移位，逻辑移位，循环移位（带进位和不带进位）

④ 转移操作

​	无条件转移JMP

​	条件转移	JZ：结果为0；JO：结果溢出；JC：结果有进位

​	调用和返回CALL和RETURN

​	陷阱（Trap）与陷阱指令

⑤ 输入输出操作

​	CPU寄存器与IP端口之间的数据传送（端口即IO接口中的寄存器）

### 4.1.2 扩展操作码指令格式

1. 扩展操作码（不定长操作码）：

全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上，最常见的边长操作码方法是扩展操作码，使操作码的长度随地址码的减少而增加，不同地址数的指令可以具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。

优点：在指令字长有限的前提下仍保持比较丰富的指令种类

缺点：增加了指令译码和分析的难度，使控制器的设计复杂化

### 4.2.1 指令寻址

1. 什么是指令寻址

确定下一条要执行的指令的存放地址（由程序计数器PC指明）

2. 顺序寻址

​	（PC）+ “1” → PC     //←此处“1”要理解为1个指令字长

​	每次指令结束后，一定会PC + “1”

3. 跳跃寻址

​	执行转移类指令导致的PC值改变

> 注：每一条指令的执行都分为“取指令”，“执行指令”两个阶段

### 4.2.2 数据寻址

1. 指令寻址 v.s. 数据寻址

寻址方式：指令寻址：下一条欲执行指令的指令地址始终由程序计数器PC给出：顺序寻址

​																	跳跃寻址

​		    数据寻址：确定本条指令的地址码指明的真实地址

2. 直接寻址

直接寻址：指令字中的形式地址A就是操作数的真实地址EA，即EA = A

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121747289.png" alt="image-20231212174755944" style="zoom:50%;" />

​															

一条指令的执行：取指令访存1次，执行指令访存1次，共访存2次

优点：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址

缺点：A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改。

3. 间接寻址

间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA = （A)

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121750143.png" alt="image-20231212175045834" style="zoom:50%;" />

优点：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）

​	    便于编制程序（用间接寻址可以方便地完成子程序返回）

缺点：指令在执行阶段要多次访存（一次间址需要两次访存，多次寻址需根据存储字的最高位确定几次访存）

4. 寄存器寻址

寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA = R；其操作数在由R~i~所指的寄存器内。

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121756231.png" alt="image-20231212175621003" style="zoom:50%;" />

一条指令的执行：取指令访存1次，执行指令访存0次，共访存1次

优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快，支持向量/矩阵运算

缺点：寄存器价格昂贵，计算机中寄存器个数有限

5. 寄存器间接寻址

寄存器间接寻址：寄存器R~i~中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA = （R~i~）

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121753362.png" alt="image-20231212175336088" style="zoom:50%;" />

一条指令的执行：取指令访存1次，执行指令访存1次，共访存2次

特点：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。

6. 隐含寻址

隐含寻址：不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121758378.png" alt="image-20231212175820065" style="zoom:50%;" />

优点：有利于缩短指令字长

缺点：需要增加存储操作数或隐含地址的硬件

7. 立即寻址

立即寻址：形成地址A就是操作数本身，又称为立即数，一般采用补码的形式。**”#“表示立即寻址特征**

一条指令的执行：取指令访存1次，执行指令访存0次，共访存1次

优点：指令执行阶段不访问主存，指令执行时间最短。

缺点：A的位数限制了立即数的范围。（如A的位数为n，且立即数采用补码时可表示的数据范围为-2^n-1^ ~ 2^n-1^ - 1

### 4.2.3 数据寻址一偏移寻址

1. 基址寻址

基址寻址：将CPU中**基址寄存器（BR）**的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即**EA = (BR) + A**

![image-20231212180604075](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121806382.png)

> 注：基址寄存器是**面向操作系统的**，其**内容由操作系统或管理程序确定**。在程序执行过程中，基址寄存器的内容不变（作为基地址），形成地址可变（作为偏移量）

当采用通用寄存器作为基址寄存器时，可由用户确定**哪个寄存器作为基址寄存器**，但其**内容仍由操作系统确定**。

优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序（整个程序在内存里边的浮动）

2. 变址寻址

变址寻址：有效地址EA等于指令字中的形式地址A与**变址寄存器IX**的内容相加之和，即**EA = (IX) + A**，其中**IX可为变址寄存器（专用）**，也**可用通用寄存器作为变址寄存器**

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121811170.png" alt="image-20231212181136852" style="zoom:50%;" />

> 注：**变址寄存器是面向用户的**，在程序执行过程中，变址寄存器的**内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。**

优点：在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。

3. 相对寻址

相对寻址：把**程序计数器PC**的内容加上指令格式中的形式地址A而形成操作数的有效地址，即**EA = (PC) + A**，其中A是相对于PC所指的地址的**偏移量**，可正可负，**补码表示**。

<img src="https://image-1304558852.cos.ap-beijing.myqcloud.com/202312121817495.png" alt="image-20231212181700170" style="zoom:50%;" />

优点：操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动（一段代码在程序内部的浮动）

相对寻址广泛应用于转移指令

4. 硬件如何实现数的“比较”

硬件视角：

* 通过“cmp指令”比较a和b（如cmp a,b）实质上是用a - b
* 相减的结果信息会记录在程序状态字寄存器中（PSW）
* 根据PSW的某几个标志位进行条件判断，来决定是否转移

PSW中有几个比特位记录上次运算的结果

* 进位/错位标志CF：最高位有进位/错位时CF = 1
* 零标志ZF：运算结果为0，则ZF = 1，否则ZF = 0
* 符号标志SF：运算结果为负，SF = 1，否则为0
* 溢出标志OF：运算结果有溢出OF = 1，否则为0

### 4.2.4 数据寻址一堆栈寻址

堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址，堆栈是存储器（或专用寄存器组）中一块特定的按“后进后出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）

### 4.3.1 高级语言与机器级代码之间的对应

1. 在汇编语言指令中，给出寄存器名

通用寄存器：eax ， ebx ， ecx ， edx

变址寄存器：esi ， ed

堆栈寄存器：ebp ， esp

2. 在汇编指令中，给出读写长度，主存地址

dword ptr [地址]  #32bit

word ptr[地址]     #16bit

Byte ptr[地址]      #8bit

在汇编指令中，直接给出常亮，即“立即寻址”，可用十进制表示，也可用十六进制（常以h结尾）

### 4.3.2 常用的x86汇编指令

1. 常见的算数运算指令**（目的操作数d不可以是常量）**

| 功能   | 英文     | 汇编指令                  | 注释                                                         |
| ------ | -------- | ------------------------- | ------------------------------------------------------------ |
| 加     | add      | **add d,s**               | #计算d+s，结果存入d                                          |
| 减     | subtract | **sub d,s**               | #计算d-s，结果存入d                                          |
| 乘     | multiply | **mul d,s<br />imul d,s** | #无符号数d*s，乘积存入d<br />#有符号数d\*s，乘积存入d        |
| 除     | divide   | **div s<br />idiv s**     | #无符号数除法edx:eax/s，商存入eax余数→edx<br />#有符号数除法edx:eax/s，商存入eax余数→edx |
| 取负数 | negative | **neg d**                 | #将d取负数，结果存入d                                        |
| 自增++ | increase | **inc d**                 | #将d++，结果存入d                                            |
| 自增-- | decrease | **dec d**                 | #将d--，结果存入d                                            |

2. 常见的逻辑运算指令

| 功能 | 英文        | 汇编指令    | 注释                                      |
| ---- | ----------- | ----------- | ----------------------------------------- |
| 与   | and         | **and d,s** | #将d,s逐位相与，结果放回d                 |
| 或   | or          | **or d,s**  | #将d,s逐位相或，结果放回d                 |
| 非   | not         | **not d**   | #将d,s逐位取反，结果放回d                 |
| 异或 | exdusive or | **xor d,s** | #将d,s逐位异或，结果放回d                 |
| 左移 | shift left  | **shl d,s** | #将d逻辑左移s位，结果放回d（通常s是常量） |
| 右移 | shift right | **shr d,s** | #将d逻辑右移s位，结果放回d（通常s是常量） |

3. 其他指令

用于**实现分支结构，循环结构**的指令：cmp，test，jmp，jxxx

用于**实现函数调用**的指令：push，pop，call，ret

用于**实现数据转移**的指令：mov

### 4.3.4 选择语句的机器级表示

1. 无条件转移指令——jmp

| jmp<地址> | #PC无条件转移至<地址>   |
| --------- | ----------------------- |
| jmp 128   | #<地址>可以用常数给出   |
| jmp eax   | #<地址>可以来自于寄存器 |
| jmp [999] | #<地址>可以来自于主存   |
| jmp NEXT  | #<地址>可以用“标号”锚定 |

2. 条件转移指令——jxxx

| cmp a,b    | #比较a和b两个数                                    |
| ---------- | -------------------------------------------------- |
| je <地址>  | #jump when equal 若a == b则跳转                    |
| jne <地址> | #jump when not equal 若a != b则跳转                |
| jg <地址>  | #jump when greater than 若a > b则跳转              |
| Jge <地址> | #jump when greater than or equal to 若a >= b则跳转 |
| jl <地址>  | #jump when less than 若a < b则跳转                 |
| jle <地址> | #jump when less than or euqal to 若a <= b则跳转    |

例：cmp eax,ebx	#比较寄存器eax和ebx里的值

​        jg NEXT		 #若eax > ebx，则跳转到NEXT

### 4.3.5 循环语句的机器级表示

1. 用条件转移指令实现循环

| mov eax,0   | #用eax保存result初值为0   | ①    |
| ----------- | ------------------------- | ---- |
| mov edx,1   | #用edx保存i，初始值为1    | ①    |
| cmp edx,100 | #比较i和100               | ②    |
| jg L2       | #若i > 100，跳转到L2执行  | ②    |
| L1:         | #循环主体                 |      |
| add eax,edx | #实现result += i          | ③    |
| inc edx     | #inc 自增指令，实现i++    | ③    |
| cmp edx,100 | #i和100比较               | ④    |
| jle L1      | #若i <= 100，跳转到L1执行 | ④    |
| L2:         | #跳出循环主体             |      |

用条件转移指令实现循环，需要4个部分构成：

​	① 循环前的初始化

​	② 是否直接跳过循环？

​	③ 循环主体

​	④ 是否继续循环

2. 用loop指令实现循环

| mov ecx,500  | #用ecx作为循环计数器                                         |
| ------------ | ------------------------------------------------------------ |
| Looptop:     | #循环的开始                                                  |
| ……           |                                                              |
| 循环主体     |                                                              |
| ……           |                                                              |
| Loop Looptop | #ecx-- ，若ecx != 0，跳转到Looptop<br />//等价于：dec ecx<br />cmp ecx,0<br />jne Looptop |

理论上，能用loop指令实现的功能一定能用条件转移指令实现，使用loop指令可能会使代码更清晰简洁

补充：loopx指令——如loopnz，loopz

loopnz——当ecx != 0 && ZF == 0时继续循环

loopz  ——当ecx != 0 && ZF == 1时继续循环

### 4.3.6.1 call和ret指令

1. call,ret指令

函数**调用**指令：call <函数名>

函数**返回**指令：ret

**call指令**的作用：

① 将<u>**IP旧值**</u>压栈保存（保存在函数的栈帧顶部）

② 设置<u>**IP新值**</u>，无条件转移至被调用函数的第一条指令

**ret指令**的作用：

从函数的栈帧顶部找到**IP旧值**，将其出栈并回复IP寄存器

函数的**栈帧（Stack Frame）**：保存函数大括号内定义的**局部变量**，保存**函数调用的相关信息**。

### 4.3.6.2如何访问栈帧

1. 标记栈帧范围：EBP，ESP寄存器

![image-20231212200209373](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122002830.png)

> 注：x86系统中，默认以4字节为栈的操作单位

2. 访问栈帧数据：push，pop指令

**push，pop**指令实现入栈，出栈操作，x86默认以**4字节**为单位。

<u>push \<data1\></u> 		//先让esp减4，再将data1压入

pop \<data2\>		   //栈顶元素出栈写入data2，再让esp加4

> 注：data1 可以使立即数，寄存器，主存地址
>
> ​        data2 可以使寄存器，主存地址

例：

push eax			#将寄存器eax的值压栈

push 985			#将立即数985压栈

push [ebp+8]		 #将主存地址[ebp+8]里的数据压栈

pop eax			   #栈顶元素出栈，写入寄存器eax

pop [ebp+8]		   #栈顶元素出栈，写入主存地址[ebp+8]

3. 访问栈帧数据：mov指令

* 可以用**mov指令，结合esp，ebp指针访问栈帧数据**
* 可以用减法/加法指令，即sub/add修改栈顶指针esp的值

### 4.3.6.3 如何切换栈帧

1. 函数**调用时**，如何切换栈帧

push ebp			#保存上一层函数的栈帧基址（ebp旧值）

mov ebp,esp		  #设置当前函数的栈帧基址（ebp新值）

​	||等价

指令：enter

2. 函数返回时，如何切换栈帧

mov esp,ebp	  	#让esp指向当前栈帧的底部

pop ebp			  #将esp所指元素出栈，写入寄存器ebp

​	||等价

指令：leave

3. 总结：函数调用的机器级表示

![image-20231212204637759](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122046395.png)

### 4.3.6.4 如何传递参数和返回值

1. 一个栈帧内可能包含哪些内容

![image-20231212204753046](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122047426.png)

> 注：
>
> * gcc编译器将每个栈帧大小设置为16B的整数倍（当前函数的栈帧除外），因此栈帧内可能出现空闲未使用的区域。
> * 通常将**局部变量**集中存储在**栈帧底部区域**
> * 通常将**调用参数**集中存储在**栈帧顶部区域**
> * **栈帧最底部一定是上一层栈帧基址（ebp旧值）**
> * **栈帧最底部一定是返回地址**（当前函数的栈帧除外）

## 4.4 CISC和RISC

1. CISC：Complex Instruction Set Computer

设计思路：一条指令完成一个复杂的基本功能

代表：x86架构，主要用于笔记本，台式机等

2. RISC：Reduced Instruction Set Computer

设计思路：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能

3. CISC v.s. RISC

| 对比项目/类别    | CISC                                 | RISC                                   |
| ---------------- | ------------------------------------ | -------------------------------------- |
| 指令系统         | 复杂，庞大                           | 简单，精简                             |
| 指令数目         | 一般大于200条                        | 一般小于200条                          |
| 指令字长         | 不固定                               | 定长                                   |
| 可访存指令       | 不加限制                             | 只有Load/Store指令                     |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成               |
| 各种指令使用频率 | 相差很大                             | 都比较常用                             |
| 通用寄存器数量   | 较少                                 | 多                                     |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 利用优化比的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制                 |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                               |

# 第五章 中央处理器

### 5.1 CPU的功能和基本结构

1. CPU的功能

① 指令控制：完成取指令，分析指令和执行指令的操作，即程序的顺序控制

② 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。

③ 时间控制：对各种操作加以时间上的控制，时间控制要为每条指令按时间顺序提供应有的控制信号。

④ 数据加工：对数据进行算数和逻辑运算

⑤ 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。

2. 运算器和控制器的功能

① 运算器：对数据进行加工

② 控制器：协调并控制计算机各部件执行程序的指令序列

取指令：操作码译码（分析指令要完成什么操作）产生操作数的有效地址

执行指令：根据分析指令得到的“操作命令”和“操作数地址”形成操作信号控制序列，控制运算器，存储器以及I/O设备完成相应的操作

中断处理：管理总线及输入输出：处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）。

3. 运算器的基本结构

① 算数逻辑单元：主要功能是进行算数/逻辑运算

② 通用寄存器组：如AX，BX，CX，DX，SP等，用于存放操作数（包括源操作数，目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址

③ 暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容

④ 累加寄存器：他是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。

⑤ 程序状态字寄存器：保留由算数逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OP），符号标志（SF），零标志（ZF），进位标志（LF），PSW中的这些位参与并决定未操作的形成。

⑥ 移位器：对运算结果进行移位运算

⑦ 计数器：控制乘除运算的操作步数

结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低

4. 控制器的基本结构

① 程序计数器：用于指出下一条指令在主存中的存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能

② 指令寄存器：用于保存当前正在执行的那条指令

③ 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号

④ 微操作信号发生器：根据IR的内容（指令），PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构由组合逻辑型和存储逻辑型两种。

⑤ 时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到

⑥ 存储器地址寄存器：用于存放所要访问的主存单元的地址

⑦ 存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息

> 注：CPU内部寄存器大致可分为两类：一类是用户可见的寄存器，可对这类寄存器编程，如通用寄存器组，程序状态字寄存器；另一类是用户不可见的寄存器，对用户时透明的，不可对这类寄存器编程，如存储器地址寄存器MAR，存储器数据寄存器MDR，指令寄存器IR。

5. CPU的基本结构

![image-20231212211732905](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122117344.png)

### 5.2 指令周期的数据流

1. 指令周期

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。

指令周期尝尝用若干机器周期来表示，机器周期又叫CPU周期，一个机器周期又包含若干时钟周期（也称节拍，T周期或CPU时钟周期，它是CPU操作的最基本单位）。

每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等。

2. 指令周期流程

![image-20231212212015508](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122120918.png)

3. 指令周期的数据流——取指周期

① 当前指令地址送至存储器地址寄存器，基座：(PC) → MAR

② CU发出控制信号，经控制总线传到主存，这里是读信号，记作：1→ R

③ 将MAR所指主存中的内容经数据总线送入MDR，记作：M(MAR) → MDR

④ 将MDR中的内容（此时是指令）送入IR，记作：(MDR) → IR

⑤ CU发出控制信号，形成下一条指令地址，记作：(PC) + 1 → PC

4. 指令周期的数据流——间址周期

① 将指令的地址码送入MAR，记作：Ad(IR) → MAR或Ad(MDR) → MAR

② CU发出控制信号，启动主存做读操作，记作：1 → R

③ 将MAR所指主存中的内容经数据总线送入MDR，记作：M(MAR) → MDR

④ 将有效地址送至指令的地址码字段，记作：MDR → Ad(IR)

间址周期的作用是取操作数的有效地址，因此间址周期结束后，MDR的内容为操作数的地址

5. 指令周期的数据流——执行周期

根据IR中的执行字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行操作不同，因此没有统一的数据流向。

6. 指令周期的数据流——中断周期

> 中断：暂停当前任务区完成其他任务，为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设SP指向栈顶元素，近栈操作是先修改指针，后存入数据。

① CU控制将SP减1，修改后的地址送入MAR记作：(SP) - 1 → SP，(SP) → MAR，本质上是将断点存入某个存储单元，假设其地址为a，故可记作：a → MAR

② CU发出控制信号，启动主存做写操作，记作：1 → W

③ 将断点（PC内容）送入MDR，记作：(PC) → MDR

④ CU控制将中断服务程序的入口地址（由向量地址形成部件产生）送入PC，记作：向量地址 → PC

7. 指令执行方案

① 单指令周期

对所有指令都选用相同的执行时间来完成。指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。

对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。

② 多指令周期

对不同类型的指令选用不同的执行步骤来完成。指令之间串行执行；可选用不同个数的时钟周期来完成不同指令的执行过程。需要更复杂的硬件设计。

③ 流水线方案

在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中，指令之间并行执行。

### 5.3.1 数据通路——单总线结构

内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线。

系统总线是指同一台计算机系统的各部件，如CPU，内存，通道和各类I/O接口间互相连接的总线。

1. 寄存器之间数据传送

比如把PC内容送至MAR，实现传送操作的流程及控制信号为：

(PC) → Bus			PC~out~有效，PC内容送总线

Bus → MAR		       MAR~in~有效，总线内容送MAR

2. 主存与CPU之间的数据传送

比如CPU从主存读取指令，实现传送操作的流程及控制信号为：

(PC) → Bus → MAR	 PC~out~和MAR~in~有效，现行指令地址 → MAR

1 → R				 CU发读命令（通过控制总线发出）

MEM(MAR) → MDR	 MDR~in~有效

MDR → Bus → IR	     MDR~out~和IR~in~有效，现行指令 → IR

3. 执行算术或逻辑运算

比如一条加法指令，微操作序列及控制信号为：

Ad(IR) → Bus → MAR 	MDR~out~和MAR~in~有效

1 → R				    CU发读命令

MEM(MAR) → 数据线→MDR	MDR~in~有效

MDR → Bus → Y		 MDR~out~和Y~in~有效，操作数 →  Y

(ACC) + (Y) → Z		    ACC~out~和ALU~in~有效，CU向ALU发送加命令

Z → ACC			       Z~out~和ACC~in~ 有效，结果 → ACC

### 5.6.1 指令流水线的基本概念

1. 指令流水线的定义

一条指令的执行过程可以分成多个阶段（或过程），根据计算机的不同，具体的分法也不同。

​			|取指|分析|执行|

取指：根据PC内容访问主存储器，取出一条指令送到IR中

分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。

执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。

① 顺序执行方式

![image-20231212214535614](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122145062.png)

传统冯·诺依曼机采用顺序执行方式，又称串行执行方式。

优点：控制简单，硬件代价小。

缺点：执行指令的速度较慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。

② 一次重叠执行方式

![image-20231212214710481](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122147824.png)

优点：程序的执行时间缩短了1/3，各功能部件的利用率明显提高。

缺点：需要付出硬件上交大开销的代价，控制过程也比顺序执行复杂了。

③ 二次重叠执行方式

![image-20231212214818999](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122148325.png)

与顺序执行方式相比，指令的执行时间缩短近2/3。这是一种理想的指令执行方式，在正常情况下，处理机中同时有3条指令在执行。

注：也可以把每条指令的执行过程分成4个或5个阶段，分成5个阶段是比较常见的做法。

2. 流水线的表示方法

① 指令执行过程图

![image-20231212214956400](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122149734.png)

主要用于分析指令执行过程以及影响流水线的因素

② 时空图

![image-20231212215037449](https://image-1304558852.cos.ap-beijing.myqcloud.com/202312122150760.png)

主要用于分析流水线的性能

3. 流水线的性能指标

① 吞吐率

吞吐率是指在单位时间内流水线所完成的任务数量或是输出结果的数量

设任务数为n：处理完成n个任务所用的时间为T~k~

则计算流水线吞吐率（TP）的最基本的公式为$TP=\frac{n}{T_k}$

② 加速比

完成同一批任务，不适用流水线所用的时间与使用流水线所用的时间之比。

设T~0~表示不适用流水线时的执行时间，即顺序执行所用的时间；T~k~表示使用流水线时的执行时间，则计算流水线加速比（S）的基本公式为$S=\frac{T_0}{T_k}$

③ 效率

流水线的设备利用率称为流水线的效率。

在时空图上，流水线的效率定义为**完成n个任务占用的时空区有效面积**与**n个任务所用的时间与k个流水段所围成的时空区总面积**之比，则流水线的效率（E）的一般公式为：
$$
E=\frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所谓成的时空区总面积}=\frac{T_0}{kT_k}
$$
